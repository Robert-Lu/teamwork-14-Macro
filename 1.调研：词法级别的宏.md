## 词法级别的宏，以 C 语言为例

#### C 的预处理阶段

我们以 C 语言的宏作为例子，C 语言中的宏在预处理阶段完成。

* There are essentially three uses of the preprocessor--directives, constants, and macros. Directives are commands that tell the preprocessor to skip part of a file, include another file, or define a constant or macro. Directives always begin with a sharp sign (#) and for readability should be placed flush to the left of the page. All other uses of the preprocessor involve processing #define'd constants or macros. Typically, constants and macros are written in ALL CAPS to indicate they are special (as we will see).


* 预处理一般有三种作用：文本指令、定义常数和定义宏。文本指令即控制预处理器选择性跳过部分文件内容（如 #ifndef）或者包含其他文件（#include）。而使用 #define 可以定义常数与宏。
* C 的常量定义有 ` #define [identifier name] [value] ` 的形式，使用场景较为普通。 


#### C 的宏展开

C 的宏有以下基本形式：

```
#define MACRO_NAME(arg1, arg2, ...) [code to expand to]
```

最简单的使用如：

``` C
#define INCREMENT(x) (x)++
```

由于 C 的宏展开是在预处理阶段完成的，没有代码中语法结构的信息，它的工作方式是完整地将对应的字符串进行拼接。

#### 一个经典的宏展开错误

定义以下的宏：

```
#define MULT(x, y) x * y
```

使用该宏时：

```c
int z = MULT(3 + 2, 4 + 2);
```

经过宏展开之后，

``` C
int z = 3 + 2 * 4 + 2;    // =13, 2 * 4 will be evaluated first!
```

解决的方法是对每个宏的参数，在替换文本中套上括号：

``` C
#define MULT(x, y) (x) * (y)
// now MULT(3 + 2, 4 + 2) will expand to (3 + 2) * (4 + 2)
```

但这并不意味着这个宏足够完善，考虑以下的宏以及它的使用：

``` C
#define ADD_FIVE(a) (a) + 5

int x = ADD_FIVE(3) * 3;
// this expands to (3) + 5 * 3, so 5 * 3 is evaluated first
// Now x is 18, not 24!
```

表达式展开为 `(3) + 5 * 3` ，仍然与预期不符。

作为完善，可以将宏定义的替换文本部分整体使用括号进行约束，

``` C
#define ADD_FIVE(a) ((a) + 5)
```

#### 多行的宏

有时我们需要宏来进行一系列操作，并使用他的**副作用**，而不需要其产生的值。

比如，交换两个变量的值，不论他们的类型，就是一种常见的需求。以下是一种常见的

```
#define SWAP(a, b)  a ^= b; b ^= a; a ^= b; 
```

