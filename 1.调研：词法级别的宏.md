## 词法级别的宏，以 C 语言为例

#### C 的预处理阶段

我们以 C 语言的宏作为例子，C 语言中的宏在预处理阶段完成。

* There are essentially three uses of the preprocessor--directives, constants, and macros. Directives are commands that tell the preprocessor to skip part of a file, include another file, or define a constant or macro. Directives always begin with a sharp sign (#) and for readability should be placed flush to the left of the page. All other uses of the preprocessor involve processing #define'd constants or macros. Typically, constants and macros are written in ALL CAPS to indicate they are special (as we will see).


* 预处理一般有三种作用：文本指令、定义常数和定义宏。文本指令即控制预处理器选择性跳过部分文件内容（如 #ifndef）或者包含其他文件（#include）。而使用 #define 可以定义常数与宏。
* C 的常量定义有 ` #define [identifier name] [value] ` 的形式，使用场景较为普通。 


#### C 的宏展开

C 的宏有以下基本形式：

```
#define MACRO_NAME(arg1, arg2, ...) [code to expand to]
```

最简单的使用如：

``` C
#define INCREMENT(x) (x)++
```

由于 C 的宏展开是在预处理阶段完成的，没有代码中语法结构的信息，它的工作方式是完整地将对应的字符串进行拼接。

#### 一个经典的宏展开错误

定义以下的宏：

```
#define MULT(x, y) x * y
```

使用该宏时：

```c
int z = MULT(3 + 2, 4 + 2);
```

经过宏展开之后，

``` C
int z = 3 + 2 * 4 + 2;    // =13, 2 * 4 will be evaluated first!
```

解决的方法是对每个宏的参数，在替换文本中套上括号：

``` C
#define MULT(x, y) (x) * (y)
// now MULT(3 + 2, 4 + 2) will expand to (3 + 2) * (4 + 2)
```

但这并不意味着这个宏足够完善，考虑以下的宏以及它的使用：

``` C
#define ADD_FIVE(a) (a) + 5

int x = ADD_FIVE(3) * 3;
// this expands to (3) + 5 * 3, so 5 * 3 is evaluated first
// Now x is 18, not 24!
```

表达式展开为 `(3) + 5 * 3` ，仍然与预期不符。

作为完善，可以将宏定义的替换文本部分整体使用括号进行约束，

``` C
#define ADD_FIVE(a) ((a) + 5)
```

#### 多行的宏

有时我们需要宏来进行一系列操作，并使用他的**副作用**，而不需要其产生的值。

比如，交换两个变量的值，不论他们的类型，就是一种常见的需求。以下是一种写法：

```
#define SWAP(a, b)  a ^= b; b ^= a; a ^= b; 
```

显然，这样的宏只能出现在程序的一般位置，才能够像函数调用语句一样作用，如果将其放在 if 语句之后，不能像单行的函数调用语句一样根据 if 的条件判断来运行或跳过整体操。

``` C
// works OK
SWAP(x, y);

// What happens now?
if(x < 0)
    SWAP(x, y);
```

可以在宏的两端套上花括号，

```
#define SWAP(a, b)  { a ^= b; b ^= a; a ^= b; }
```

但对于以下的使用，会破坏 if else 语句的逻辑流。（注意宏之后有分号，展开后，这个分号会造成影响）

```
// What happens now?
if(x < 0)
    SWAP(x, y);
else
    SWAP(x, z); 
```

一种较为通用的 trade-off 是这样的，使用一个 do-while 循环，并且，对于这样的结构冗余，编译器可以轻松地优化。

```
#define SWAP(a, b)  do { a ^= b; b ^= a; a ^= b; } while ( 0 )
```
#### 杂项

#####  宏定义不一定需要写在一行内

```
#define SWAP(a, b)  {                   \
                        a ^= b;         \
                        b ^= a;         \ 
                        a ^= b;         \
                    } 
```
\#\# : 连接

```
#define BUILD_FIELD(field) my_struct.inner_struct.union_a.##field
```

可以用 `BUILD_FIELD(name)` 来展开为 `my_struct.inner_struct.union_a.name` 。

\# : 字符串化

```
#define PRINT(token) printf(#token " is %d", token)
```

可以用 `PRINT(f(2)+1);` 来展开为 `printf("f(2)+1" " is %d", f(2)+1);`