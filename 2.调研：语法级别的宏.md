**关于宏**

1. A macro in computer science is a rule or pattern that specifies how a certain input sequence (often a sequence of characters) should be mapped to a replacement output sequence according to a defined procedure. 
2. 简单的说，宏是通过转换 (transformation)而实现的操作符， 宏定义了一套将给定序列转化为替换序列的规则和模式。
3. 宏的主要作用在于简化代码，减少代码冗余度，简单的过程绑定与运算符重定义。

**类lisp宏**

1. There are three main macro systems in use:

   >  -  [CommonLisp](http://wiki.c2.com/?CommonLisp) macros are functions that transform [EssExpressions](http://wiki.c2.com/?EssExpressions) to [EssExpressions](http://wiki.c2.com/?EssExpressions) using QuasiQuote and UnQuote. See [CommonLispMacroExamples](http://wiki.c2.com/?CommonLispMacroExamples)
   >  -  The [SchemeLanguage](http://wiki.c2.com/?SchemeLanguage) standard macro system, called SyntaxRules, are safe from variable capture (called hygiene) and written using a very clear pattern matching style. However they cannot do everything that can be done in [CommonLisp](http://wiki.c2.com/?CommonLisp)macros. See [DefineSyntax](http://wiki.c2.com/?DefineSyntax) for some exposition and [SchemeMacroExamples](http://wiki.c2.com/?SchemeMacroExamples) for some examples.
   >  -  The [SchemeLanguage](http://wiki.c2.com/?SchemeLanguage) [SyntaxCase](http://wiki.c2.com/?SyntaxCase) macro system offers the benefits of both: pattern matching and hygiene when you want, with the ability to circumvent hygiene when so desired. See [SchemeMacroExamples.](http://wiki.c2.com/?SchemeMacroExamples)

2. lisp中包含很多已有的宏，如setf是对变量赋值的宏，甚至defmarco本身都是宏。

3. lisp宏与一般词法级别的宏的区别在于它不是简单的替换，而是包含了一定逻辑意义的替换，是更强大的替换。

   >  由于lisp的本身语言特性，即数据与过程（结构）的统一，使得lisp能够简单地做到在语法级别的替换规则定义。 Lisp is different. Lisp macros *do* have access to the parser, and it is a really simple parser. A Lisp macro is not handed a string, but a preparsed piece of source code in the form of a list, because the source of a Lisp program is not a string; it is a list.

4. During a macroexpansion phase, the Lisp expression will be passed to the macro function. This macro function can do arbitrary computation at macroexpansion time. 

   >  在common lisp中，宏通常通过调用 `defmacro` 来定义。一个 `defmacro` 看起来很像` defun` 。但是与其定义一个函数调用应该产生的值，它定义了该怎么翻译出一个函数调用。举例来说，一个将其参数设为 nil 的宏可以定义成如下:
   >
   >  ```
   >  (defmacro nil! (x)
   >    (list 'setf x nil))
   >  ```
   >
   >  这定义了一个新的操作符，称为 nil! ，它接受一个参数。一个这样形式` (nil! a) `的调用，会在求值或编译前，被翻译成 `(setf a nil)` 。所以如果我们输入` (nil! x) `至顶层，
   >
   >  ```
   >  > (nil! x)
   >  NIL
   >  > x
   >  NIL
   >  ```
   >
   >  它完全等同于输入表达式 (setf x nil) 。

5. The macro language is Lisp itself, so the full power of the language is available.同样， lisp编译宏展开过程得到的代码仍然是 Lisp code. 

   >  在台面底下，宏只是转换成表达式的函数。举例来说，如果你传入这个形式 (nil! a) 的表达式给这个函数
   >
   >  ```
   >  (lambda (expr)
   >    (apply #'(lambda (x) (list 'setf x nil))
   >       (cdr expr)))
   >  ```
   >
   >  它会返回 (setf a nil) 。当你使用 defmacro ，你定义一个类似这样的函数。 macroexpand-1 全部所做的事情是，当它看到一个表达式的 car 是宏时，将表达式传给对应的函数。

6. 设计宏
   >  撰写宏是一种独特的程序设计，它有着独一无二的目标与问题。能够改变编译器所看到的东西，就像是能够重写它一样。所以当你开始撰写宏时，你需要像语言设计者一样思考。


#### mzscheme的define-macro

  * 语法
    ```
    (define-macro   macro-name
    (lambda  macro-args)
      macro-body   ......) 
    ```
  * eg.定义when

    ```
     (define-macro   when
      (lambda    (test .   branch)
          `(if    ,test
           (begin    ,@brach))))    
    ```

  其中 `` ` `` 重音号引入模版，逗号开始的符号为参数，逗号和@开始的被当为列表。

* #### MIT的define-syntax和syntax-rules

  * 语法

    ```
    (define    macro-name
         (syntax-rules   ()
             ( (template)  operation)
                ......)  )     
    ```

    上面的when的定义：

    ```
    (define-syntax   when
        (syntax-rules ()
           ((when test expr ...) (if test (begin expr ...)))))
    ```

    when的定义非常简洁，主要是这种语法的模版非常直观，其中“...”就可以表示有多个参数。

  *  From r5rs

    Syntax definitions are valid only at the top level of a <program>. They have the following form:

    (define-syntax <keyword> <transformer spec>)

    <Keyword> is an identifier, and the <transformer spec> should be an instance of syntax-rules. The top-level syntactic environment is extended by binding the <keyword> to the specified transformer.

    There is no define-syntax analogue of internal definitions.

    Although macros may expand into definitions and syntax definitions in any context that permits them, it is an error for a definition or syntax definition to shadow a syntactic keyword whose meaning is needed to determine whether some form in the group of forms that contains the shadowing definition is in fact a definition, or, for internal definitions, is needed to determine the boundary between the group and the expressions that follow the group. For example, the following are errors：

    ```
    (define define 3)

    (begin (define begin list))

    (let-syntax
      ((foo (syntax-rules ()
              ((foo (proc args ...) body ...)
               (define proc
                 (lambda (args ...)
                   body ...))))))
      (let ((x 3))
        (foo (plus x y) (+ x y))
        (define foo x)
        (plus foo x)))
    ```