* #### mzscheme的define-macro

  * 语法

      (define-macro   macro-name
      (lambda  macro-args)
       macro-body   ......)       
  * eg.定义when

       (define-macro   when
       	(lambda    (test .   branch)
       		`(if    ,test
       		 (begin    ,@brach))))    

  其中“·”重音号引入模版，逗号开始的符号为参数，逗号和@开始的被当为列表。

* #### MIT的define-syntax和syntax-rules

  * 语法

    ```
    (define    macro-name
         (syntax-rules   ()
             ( (template)  operation)
                ......)  )     
    ```

    上面的when的定义：

    ```
    (define-syntax   when
        (syntax-rules ()
           ((when test expr ...) (if test (begin expr ...)))))
    ```

    when的定义非常简洁，主要是这种语法的模版非常直观，其中“...”就可以表示有多个参数。

  *  From r5rs

    Syntax definitions are valid only at the top level of a <program>. They have the following form:

    (define-syntax <keyword> <transformer spec>)

    <Keyword> is an identifier, and the <transformer spec> should be an instance of syntax-rules. The top-level syntactic environment is extended by binding the <keyword> to the specified transformer.

    There is no define-syntax analogue of internal definitions.

    Although macros may expand into definitions and syntax definitions in any context that permits them, it is an error for a definition or syntax definition to shadow a syntactic keyword whose meaning is needed to determine whether some form in the group of forms that contains the shadowing definition is in fact a definition, or, for internal definitions, is needed to determine the boundary between the group and the expressions that follow the group. For example, the following are errors：

    ```
    (define define 3)

    (begin (define begin list))

    (let-syntax
      ((foo (syntax-rules ()
              ((foo (proc args ...) body ...)
               (define proc
                 (lambda (args ...)
                   body ...))))))
      (let ((x 3))
        (foo (plus x y) (+ x y))
        (define foo x)
        (plus foo x)))
    ```

